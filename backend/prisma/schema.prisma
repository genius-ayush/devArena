
generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Setter {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  contests Contest[]

  @@map("setters")
}

model Participant {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  contestParticipations ContestParticipation[]
  submissions          Submission[]

  @@map("participants")
}

model Contest {
  id           String   @id @default(cuid())
  name         String
  description  String
  questionCount Int
  totalMarks   Int
  startTime    DateTime
  endTime      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Foreign keys
  setterId String

  // Relations
  setter       Setter                 @relation(fields: [setterId], references: [id], onDelete: Cascade)
  questions    Question[]
  participations ContestParticipation[]

  @@map("contests")
}

model Question {
  id               String @id @default(cuid())
  problemStatement String @db.Text
  checkParameter   String @db.Text 
  marks           Int
  questionOrder   Int

  // Foreign keys
  contestId String

  // Relations
  contest     Contest      @relation(fields: [contestId], references: [id], onDelete: Cascade)
  submissions Submission[]

  @@unique([contestId, questionOrder]) 
  @@map("questions")
}

// Junction table for many-to-many relationship between Contest and Participant
model ContestParticipation {
  id            String    @id @default(cuid())
  participantId String
  contestId     String
  joinedAt      DateTime  @default(now())
  startedAt     DateTime? // When participant actually started the contest
  finishedAt    DateTime? // When participant finished/submitted
  totalScore    Int       @default(0)
  status        ParticipationStatus @default(REGISTERED)

  // Relations
  participant Participant  @relation(fields: [participantId], references: [id], onDelete: Cascade)
  contest     Contest      @relation(fields: [contestId], references: [id], onDelete: Cascade)
  submissions Submission[]

  @@unique([participantId, contestId]) 
  @@map("contest_participations")
}

// Individual question attempts/submissions
model Submission {
  id                    String   @id @default(cuid())
  participantId         String
  contestId             String
  questionId            String
  contestParticipationId String
  answer                String   @db.Text
  score                 Int      @default(0)
  isCorrect             Boolean  @default(false)
  submittedAt           DateTime @default(now())
  
  // For tracking multiple attempts if allowed
  attemptNumber Int @default(1)

  // Relations
  participant         Participant          @relation(fields: [participantId], references: [id], onDelete: Cascade)
  question            Question             @relation(fields: [questionId], references: [id], onDelete: Cascade)
  contestParticipation ContestParticipation @relation(fields: [contestParticipationId], references: [id], onDelete: Cascade)

  @@unique([contestParticipationId, questionId, attemptNumber]) // Track multiple attempts
  @@map("submissions")
}

// Enum for participation status
enum ParticipationStatus {
  REGISTERED  // Registered but not started
  IN_PROGRESS // Currently attempting
  COMPLETED   // Finished the contest
  DISQUALIFIED
}

// Optional: Leaderboard view (you can create this as a database view)
// This is just a model representation - you'd create the actual view in your migration
model Leaderboard {
  id            String @id @default(cuid())
  contestId     String
  participantId String
  participantName String?
  totalScore    Int
  rank          Int
  finishedAt    DateTime?

  @@unique([contestId, participantId])
  @@map("leaderboard")
}